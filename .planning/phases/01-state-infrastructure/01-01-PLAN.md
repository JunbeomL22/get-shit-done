---
phase: 01-state-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs
autonomous: true
requirements:
  - STATE-01
  - STATE-02
  - STATE-03

must_haves:
  truths:
    - "Running `gsd-tools yolo-state write` with active, start-phase, and timestamp flags creates a complete workflow.yolo stanza in config.json"
    - "Running `gsd-tools yolo-state read` returns the full yolo stanza as JSON, or empty object if absent"
    - "Running `gsd-tools yolo-state clear` removes the workflow.yolo stanza entirely from config.json"
    - "Running `gsd-tools yolo-state fail` sets active to false and records failed_phase and failure_reason"
    - "Running `gsd-tools config-delete workflow.yolo` removes the key from config.json"
    - "The yolo-state write command performs read-after-write verification and errors if the stanza is incomplete"
  artifacts:
    - path: "/home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs"
      provides: "config-delete command and yolo-state compound command with read/write/clear/fail subcommands"
      contains: "cmdConfigDelete"
  key_links:
    - from: "yolo-state write"
      to: "config.json workflow.yolo stanza"
      via: "config-set calls + read-after-write verification"
      pattern: "config-set.*workflow\\.yolo"
    - from: "yolo-state clear"
      to: "config-delete"
      via: "cmdConfigDelete('workflow.yolo')"
      pattern: "cmdConfigDelete"
    - from: "dispatch switch"
      to: "cmdConfigDelete, cmdYoloState"
      via: "case 'config-delete' and case 'yolo-state' in main switch"
      pattern: "case 'config-delete'|case 'yolo-state'"
---

<objective>
Add YOLO session state commands to gsd-tools.cjs: a generic `config-delete` command for removing dot-notation keys from config.json, and a `yolo-state` compound command with `write`, `read`, `clear`, and `fail` subcommands for atomic YOLO state management.

Purpose: These commands are the foundation for all YOLO state operations. Phase 2 (Launcher) and Phase 3 (Integration) depend on these commands existing and working correctly. The `config-delete` command fills a gap in the existing config API (config-set/config-get exist but cannot delete keys). The `yolo-state` compound command provides atomic operations that prevent partial writes and include built-in verification.

Output: Modified gsd-tools.cjs with two new command groups and their dispatch entries.
</objective>

<execution_context>
@/home/junbeom/.claude/get-shit-done/workflows/execute-plan.md
@/home/junbeom/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-state-infrastructure/01-RESEARCH.md
@/home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config-delete command to gsd-tools.cjs</name>
  <files>/home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs</files>
  <action>
Add a `cmdConfigDelete(cwd, keyPath, raw)` function to gsd-tools.cjs. Place it immediately after the existing `cmdConfigGet` function (around line 730).

**Implementation:**
1. Read config.json from `path.join(cwd, '.planning', 'config.json')`
2. Traverse the dot-notation key path to find the parent object and target key
3. Use JavaScript `delete` operator to remove the key
4. If the parent object becomes empty after deletion, recursively clean up empty parent objects (e.g., deleting `workflow.yolo.active` when `yolo` only has `active` should leave `workflow.yolo` as `{}` -- but do NOT remove the parent `workflow` object, only remove empty intermediate objects created solely for the deleted key)
5. Actually, keep it simple: just delete the target key at the specified path. Do not attempt recursive cleanup of empty parents. This matches the behavior of `config-set` which creates intermediates without cleanup.
6. Write back the config.json
7. Output `{ deleted: true, key: keyPath }` on success via the existing `output()` helper
8. If the key does not exist, output `{ deleted: false, key: keyPath, reason: "key not found" }` (do NOT throw an error -- idempotent deletes are safer)

**Error handling:**
- If config.json does not exist: call `error('No config.json found at ' + configPath)` (same pattern as `cmdConfigGet`)
- If config.json is malformed: call `error('Failed to read config.json: ' + err.message)`
- If write fails: call `error('Failed to write config.json: ' + err.message)`

**Dispatch entry:**
Add `case 'config-delete':` in the main switch block, immediately after the `case 'config-get':` block (around line 5042). Wire it to `cmdConfigDelete(cwd, args[1], raw)`.

**Follow the exact code style of cmdConfigSet and cmdConfigGet** -- same variable names, same fs.existsSync/readFileSync/writeFileSync pattern, same error() calls.
  </action>
  <verify>
Run from the project root:
```bash
# Write a test key
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs config-set workflow.test_delete.nested true
# Delete it
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs config-delete workflow.test_delete.nested --raw
# Verify it returns deleted: true
# Try to read it -- should error with "Key not found"
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs config-get workflow.test_delete.nested --raw 2>&1 || true
# Delete again -- should return deleted: false (idempotent)
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs config-delete workflow.test_delete --raw
```
  </verify>
  <done>
`config-delete` command exists in gsd-tools.cjs, is wired in the dispatch switch, deletes dot-notation keys from config.json, and handles missing keys idempotently (returns deleted: false instead of erroring).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add yolo-state compound command to gsd-tools.cjs</name>
  <files>/home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs</files>
  <action>
Add a `cmdYoloState(cwd, subcommand, args, raw)` function to gsd-tools.cjs. Place it after the `cmdConfigDelete` function added in Task 1.

**Subcommands:**

**`yolo-state write --start-phase N`**
1. Generate timestamp using the same logic as `cmdCurrentTimestamp` (i.e., `new Date().toISOString()`)
2. Read config.json, set `workflow.yolo` to the full stanza object atomically (single write, not three separate config-set calls):
   ```json
   {
     "active": true,
     "start_phase": N,
     "timestamp": "<generated ISO timestamp>"
   }
   ```
   Where N is parsed from `--start-phase` arg (required; error if missing). Parse as number if numeric.
3. Write config.json back
4. **Read-after-write verification:** Immediately re-read config.json from disk (fresh `fs.readFileSync`), parse it, and check that `workflow.yolo.active === true`, `workflow.yolo.start_phase` matches the input, and `workflow.yolo.timestamp` is a non-empty string. If any check fails, call `error('YOLO state write verification failed: ...')` with details of what mismatched.
5. Output the written stanza: `{ active: true, start_phase: N, timestamp: "..." }`

**`yolo-state read`**
1. Read config.json
2. Return `config.workflow.yolo` if it exists, or `{}` if `workflow` or `workflow.yolo` is absent
3. Do NOT error if the stanza is missing -- return empty object (this is the expected state when no YOLO run is active)
4. Output the stanza (or empty object)

**`yolo-state clear`**
1. Read config.json
2. If `workflow.yolo` exists, delete it using the same delete logic as `cmdConfigDelete` (or just `delete config.workflow.yolo`)
3. Write config.json back
4. If `workflow.yolo` did not exist, still succeed silently (idempotent)
5. Output `{ cleared: true }`

**`yolo-state fail --phase N --reason "text"`**
1. Read config.json
2. Set `workflow.yolo.active` to `false`
3. Set `workflow.yolo.failed_phase` to N (parsed from `--phase` arg; required)
4. Set `workflow.yolo.failure_reason` to the reason string (parsed from `--reason` arg; required)
5. Preserve existing fields (`start_phase`, `timestamp`) -- only modify `active` and add `failed_phase`/`failure_reason`
6. Write config.json back
7. Output the updated stanza

**Argument parsing for all subcommands:**
Parse `--start-phase`, `--phase`, `--reason` from the args array using the same `args.indexOf('--flag')` pattern used throughout gsd-tools.cjs (see cmdStateRecordMetric around line 1871 for examples).

**Dispatch entry:**
Add `case 'yolo-state':` in the main switch block, after the `case 'config-delete':` block. Wire it to:
```javascript
case 'yolo-state': {
  const subcommand = args[1];
  cmdYoloState(cwd, subcommand, args, raw);
  break;
}
```

**Error cases:**
- Missing subcommand: `error('Usage: yolo-state <read|write|clear|fail>')`
- Unknown subcommand: `error('Unknown yolo-state subcommand: ' + subcommand)`
- `write` missing `--start-phase`: `error('yolo-state write requires --start-phase <N>')`
- `fail` missing `--phase`: `error('yolo-state fail requires --phase <N>')`
- `fail` missing `--reason`: `error('yolo-state fail requires --reason <text>')`
  </action>
  <verify>
Run from the project root:
```bash
# Write yolo state
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state write --start-phase 1 --raw
# Should output JSON with active:true, start_phase:1, timestamp

# Read yolo state
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state read --raw
# Should output same stanza

# Mark failure
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state fail --phase 2 --reason "verification gaps found" --raw
# Should output stanza with active:false, failed_phase:2

# Clear yolo state
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state clear --raw
# Should output { cleared: true }

# Read after clear
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state read --raw
# Should output {}

# Verify config.json has no workflow.yolo key
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs config-get workflow --raw
# Should show workflow object without yolo key
```
  </verify>
  <done>
`yolo-state` compound command exists in gsd-tools.cjs with all four subcommands (write, read, clear, fail). The write subcommand performs atomic stanza creation with built-in read-after-write verification. The read subcommand returns empty object when no stanza exists. The clear subcommand is idempotent. The fail subcommand preserves existing fields while adding failure info.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, run the full lifecycle from the project root:

```bash
# 1. Start clean -- ensure no yolo stanza exists
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state clear --raw

# 2. Write state (STATE-01)
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state write --start-phase 1 --raw

# 3. Read state -- should survive being called in a new process (STATE-02)
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state read --raw

# 4. Also verify via config-get (matches ROADMAP success criteria #1)
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs config-get workflow.yolo --raw

# 5. Mark failure (STATE-03 failure path)
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state fail --phase 2 --reason "verification gaps found" --raw

# 6. Clear state (STATE-03 manual override path)
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state clear --raw

# 7. Confirm gone
node /home/junbeom/.claude/get-shit-done/bin/gsd-tools.cjs yolo-state read --raw
# Should output {}
```
</verification>

<success_criteria>
1. `gsd-tools config-delete <key.path>` removes any dot-notation key from config.json
2. `gsd-tools yolo-state write --start-phase N` creates the complete workflow.yolo stanza atomically with read-after-write verification
3. `gsd-tools yolo-state read` returns the stanza or empty object
4. `gsd-tools yolo-state clear` removes the stanza (idempotent)
5. `gsd-tools yolo-state fail --phase N --reason "text"` preserves state while marking failure
6. All commands follow existing gsd-tools.cjs code style and patterns
</success_criteria>

<output>
After completion, create `.planning/phases/01-state-infrastructure/01-01-SUMMARY.md`
</output>
